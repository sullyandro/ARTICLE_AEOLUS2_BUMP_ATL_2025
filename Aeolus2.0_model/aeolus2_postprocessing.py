################################################################################
#
# Author:       Sullyandro Guimaraes (sullyandro@pik-potsdam.de)
# Colaborators: Stefan Petri, Masoud Rostami
# Date:         25.01.2024
# Type:         Python3
#
# Description:
# This is an adaptation of npytonc.py
# Script to Post-process the output (npz) from Aeolus2.0 into a single netcdf4.
# 
# Note: 
# for smooth grid (768x384), 408 timesteps postprocessed result in 9.6 GB.
#
################################################################################

import os
import sys
import argparse
import numpy as np
import humanize
import warnings
from glob import glob
from NetCDFOutput import NetCDFOutput
warnings.filterwarnings("ignore")

parser = argparse.ArgumentParser()
parser.add_argument('--output_folder', type=str, help='output folder',       default='output_folder')
parser.add_argument('--output_file',   type=str, help='output_file',         default='output_file')
parser.add_argument('--overwrite',               help='just do --overwrite', action='store_true')
args = parser.parse_args()

output_folder = args.output_folder
output_file   = args.output_file
overwrite     = args.overwrite



print('')
print('Aeolus2.0 Post-processing')
print('')

# Start date of the simulation
timeunits = 'days since 1980-06-01 00:00'

# Location of Aeolus2.0 Output to be processed

# output_folder, output_file = '../Data/Aeolus2.0_Output_Dry_Control',           'Aeolus2.0_Output_Dry_Control.nc'
# output_folder, output_file = '../Data/Aeolus2.0_Output_Dry_Barotropic_Weak',   'Aeolus2.0_Output_Dry_Barotropic_Weak.nc'
# output_folder, output_file = '../Data/Aeolus2.0_Output_Dry_Barotropic_Strong', 'Aeolus2.0_Output_Dry_Barotropic_Strong.nc'
# output_folder, output_file = '../Data/Aeolus2.0_Output_Dry_Baroclinic_Weak',   'Aeolus2.0_Output_Dry_Baroclinic_Weak.nc'
# output_folder, output_file = '../Data/Aeolus2.0_Output_Dry_Baroclinic_Strong', 'Aeolus2.0_Output_Dry_Baroclinic_Strong.nc'
# output_folder, output_file = '../Data/Aeolus2.0_Output_MC_Control',            'Aeolus2.0_Output_MC_Control.nc'           
# output_folder, output_file = '../Data/Aeolus2.0_Output_MC_Barotropic_Weak',    'Aeolus2.0_Output_MC_Barotropic_Weak.nc'
# output_folder, output_file = '../Data/Aeolus2.0_Output_MC_Barotropic_Strong',  'Aeolus2.0_Output_MC_Barotropic_Strong.nc'     
# output_folder, output_file = '../Data/Aeolus2.0_Output_MC_Baroclinic_Weak',    'Aeolus2.0_Output_MC_Baroclinic_Weak.nc'
# output_folder, output_file = '../Data/Aeolus2.0_Output_MC_Baroclinic_Strong',  'Aeolus2.0_Output_MC_Baroclinic_Strong.nc' 

output_nc = '{}/{}'.format(output_folder, output_file)

if os.path.exists(output_nc) and overwrite:
	print('exists -->', output_nc, humanize.naturalsize(os.path.getsize(output_nc)), '--> will be overwritten')
	os.system('rm {}'.format(output_nc))
	
if os.path.exists(output_nc) and not overwrite:
    print('exists -->', output_nc, humanize.naturalsize(os.path.getsize(output_nc)), '--> will not be overwritten')
    exit()


# Original npz files generated by the model

files_out = '{}/output_*.npz'.format(output_folder)
files_npz = sorted(glob(files_out))

print()
if len(files_npz) == 0:
    print('fail --> not found', files_out)
    exit()
else:
    print('npz files:')
    print(files_npz)


print()
print('Preparing the NetCDF')
print()

# Open first npz file to obtain axis information

d    = np.load(files_npz[0])
lons = (( d['lamda']/(2.*np.pi) )*360.0) - 180.0
phi  = (np.pi/2.0) - d['theta']
lats = ( phi/(2.*np.pi) )*360.0

# Creating the NetCDF output file

nc_gridinfo = { 'lons': lons, 'lats': lats }

nc_out = NetCDFOutput(comm=None, coords=nc_gridinfo, f=output_nc, isrestart=False, timeunits=timeunits, comment='from aeolus2_postprocessing.py')

# Adding variables name

for v in d.files:
        
    if v in ['t', 'lamda', 'theta']: continue
    
    print('AddVariable -->', v)
    
    if   d[v].ndim == 0:
        
        nc_out.AddVariable(v, axes=(nc_out.timeaxisname))
        
    elif d[v].ndim == 2:
        
        nc_out.AddVariable(v, axes=(nc_out.timeaxisname, nc_out.lataxisname, nc_out.lonaxisname))
        
    else:
        
        print('Warning: cannot handle variable', v, 'with', d[v].ndim, 'dimensions')


# Adding variables data itself

ct = 0
d_t = []
print()

for i,f in enumerate(files_npz):
    
    d = np.load(f)
    
    d_t.append(d['t'][:])
    
    # checking if the npz and the time axis match.
    # if not, the axis is fixed.
    # this is a caution given a bug in numbering the npz files in restarted runs.
    diff = ''
    if i > 2: 
        if d_t[-2] == d_t[-1]:
            d_t[-1] = d_t[-1] + (d_t[-2] - d_t[-3])
            diff = 'new {:10} <--'.format(str(round(d_t[-1][0],5)))

    print('load --> {}   |   time  npz {:10}  {}'.format(f, str(round(d['t'][0],5)), diff))
    
    for v in d.files:
        
        if v in ['t', 'lamda', 'theta']: continue
    
        nc_out.WriteVar(v, d[v][:,::-1], d_t[-1])
 
    ct += 1

nc_out.close

print('total number of timesteps -->', ct)
print()


# Applying new time axis

pwd  = os.getcwd()
cmd1 = 'cdo -O -f nc4 -z zip settaxis,1980-06-01,06:00,6h {0}/{1} {0}/{2}'.format(pwd, output_nc, output_nc+'_settaxis.nc')
print('')
print(cmd1)
os.system(cmd1)

cmd2 = 'mv {0}/{1} {0}/{2}'.format(pwd, output_nc+'_settaxis.nc', output_nc)
print('')
print(cmd2)
os.system(cmd2)


if os.path.exists(output_nc):
	print('generated -->', output_nc, humanize.naturalsize(os.path.getsize(output_nc)))
else:
	print('fail -->', output_nc)






